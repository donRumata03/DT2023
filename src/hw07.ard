\import Data.Bool
\import Data.Maybe
\import Function.Meta
\import Logic
\import Meta
\import lect07
\open Nat(+)

-- 1. Определите функцию swap несколькими способами.

-- При помощи \cowith и доступа к полям.
\func swap {A B : \Type} (p : Pair A B) : Pair B A \cowith
  | fst_ => p.snd_
  | snd_ => p.fst_

-- При помощи \new и паттерн матчинга.
\func swap' {A B : \Type} (p : Pair A B) : Pair B A =>
  \let | (f, s) => p \in
  \new Pair {
    | fst_ => s
    | snd_ => f
  }

-- При помощи \new и доступа к полям.
\func swap'' {A B : \Type} (p : Pair A B) : Pair B A => \new Pair {
  | fst_ => snd_ {p}
  | snd_ => fst_ {p}
}

-- 2. Докажите, что swap (swap p) = p.

\func swap-involutive {A B : \Type} (p : Pair A B) : swap (swap p) = p => idp

-- 3. Докажите, что тип PosNat 0 пустой, а тип PosNat 1 нет.

\func zero-isNotPos (p : PosNat 0) : Empty => cases (isPos p.n arg addPath) \with {
  | false, p1 => p.p
}

\func one-isPos : PosNat 1 \cowith
  | p => ()

-- 4. Определите \record, состоящий из пар взаимно простых натуральных чисел.
--    Определите тип, состоящий из натуральных чисел, взаимно простых с 60.

\record ReciprocallyPrime (n : Nat) (m : Nat)
  | p : \Pi (d : Nat)
  -> \Sigma (Nat.mod n d = 0) (Nat.mod m d = 0)
      -> d = 1

\func ReciprocallyPrimeWith60 => ReciprocallyPrime { | n => 60 }

\record ReciprocallyPrimeWith60' \extends ReciprocallyPrime
  | n  => 60

-- 5. Закончите определение класса монад. Этот класс должен содержать все монадные законы и реализовывать все поля из класса функторов.

\class Monad \extends Functor {
  | return {A : \Set} : A -> F A
  | \infixl 1 >>= {A B : \Set} : F A -> (A -> F B) -> F B

  -- Monadic laws
  | left-id {A B : \Set} (a : A) (h : A -> F B) : (return a >>= h) = h a
  | right-id {A B : \Set} (m : F B) : (m  >>= return) = m
  | comp-assoc {A B C : \Set} (m : F A) (g : A -> F B) (h : B -> F C) : ((m >>= g) >>= h) = (m >>= (\lam x => g x >>= h))

  -- Implementation of fmap based on monad stuff and proof of its properties based on monadic laws
  \default fmap {A B : \Set} (func : A -> B) (f : F A) : F B => f >>= (\lam a => return $ func a)
  \default fmap-id => {?}
  \default fmap-comp => {?}
}

-- 6. Определите \instance Monad для Maybe.

\instance MaybeMonad : Monad Maybe => {?}

-- 7. Определите \instance Monad для State и State'.

\record State (S A : \Type)
  | state : S -> \Sigma S A

\data State' (S A : \Type)
  | state' (S -> \Sigma S A)
